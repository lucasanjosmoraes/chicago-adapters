package kafkagoadapter

import (
	"context"
	"crypto/tls"
	"strings"
	"time"

	"github.com/lucasanjosmoraes/chicago-ports/pkg/log"
	"github.com/lucasanjosmoraes/chicago-ports/pkg/publisher"
	"github.com/segmentio/kafka-go"
	"github.com/segmentio/kafka-go/sasl/plain"
)

// ProducerConfig contains all the attributes required to initialize the Producer.
type ProducerConfig struct {
	Brokers             string
	User                string
	Password            string
	LogConnections      bool
	TLS                 bool
	SkipTLSVerification bool
}

// ProducerAdapter implements publisher.Producer to produce events on Kafka topics,
// using the kafka-go lib.
type ProducerAdapter struct {
	Config    ProducerConfig
	Logger    log.Logger
	producers map[string]*kafka.Writer
}

// NewProducer instantiates a new ProducerAdapter, but also helps us to validate
// if ProducerAdapter implements publisher.Producer correctly.
func NewProducer(l log.Logger, c ProducerConfig) publisher.Producer {
	return ProducerAdapter{
		Logger:    l,
		Config:    c,
		producers: make(map[string]*kafka.Writer),
	}
}

func (a ProducerAdapter) getProducer(t string) *kafka.Writer {
	w, found := a.producers[t]
	if found {
		return w
	}

	mechanism := plain.Mechanism{
		Username: a.Config.User,
		Password: a.Config.Password,
	}
	transport := &kafka.Transport{
		DialTimeout: 30 * time.Second,
		SASL:        mechanism,
	}
	if a.Config.TLS {
		tlsConfig := &tls.Config{}
		if a.Config.SkipTLSVerification {
			tlsConfig.InsecureSkipVerify = true
		}

		transport.TLS = tlsConfig
	}

	brokers := strings.Split(a.Config.Brokers, ",")
	wForT := &kafka.Writer{
		Addr:      kafka.TCP(brokers...),
		Topic:     t,
		Balancer:  &kafka.RoundRobin{},
		Transport: transport,
	}
	if a.Config.LogConnections {
		wForT.Logger = KafkaLogger{Logger: a.Logger}
	}

	a.producers[t] = wForT

	return wForT
}

// Stop finishes adapter and dispose its resources.
func (a ProducerAdapter) Stop(_ context.Context) error {
	for _, w := range a.producers {
		err := w.Close()
		if err != nil {
			return err
		}
	}

	a.producers = nil
	return nil
}

// StopError return the error generated by the context.
func (a ProducerAdapter) StopError() error {
	return context.Canceled
}

// transformToKafkaHeaders parses the abstract headers representation
// to an acceptable kafka-go headers representation.
func transformToKafkaHeaders(hs []publisher.EventHeader) []kafka.Header {
	kafkaHs := make([]kafka.Header, 0)

	for _, h := range hs {
		kafkaHs = append(kafkaHs, kafka.Header{
			Key:   h.Key,
			Value: h.Value,
		})
	}

	return kafkaHs
}

// WriteEvent publish a single event, given its key, value and headers.
func (a ProducerAdapter) WriteEvent(ctx context.Context, topic string, event publisher.Event) error {
	p := a.getProducer(topic)

	return p.WriteMessages(ctx,
		kafka.Message{
			Key:     event.Key,
			Value:   event.Value,
			Headers: transformToKafkaHeaders(event.Headers),
		},
	)
}

// WriteEvents publish a events list, given they keys, value and headers, all at
// the same time.
func (a ProducerAdapter) WriteEvents(ctx context.Context, topic string, events []publisher.Event) error {
	messages := make([]kafka.Message, 0)
	p := a.getProducer(topic)

	for _, event := range events {
		messages = append(messages, kafka.Message{
			Key:     event.Key,
			Value:   event.Value,
			Headers: transformToKafkaHeaders(event.Headers),
		})
	}

	return p.WriteMessages(ctx,
		messages...,
	)
}
